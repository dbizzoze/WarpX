/* Copyright 2023 David Grote and David Bizzozero
 *
 * This file is part of WarpX.
 *
 * License: BSD-3-Clause-LBNL
 */
#ifndef WARPX_ACCELERATORLATTICE_LATTICEELEMENTS_SOLENOID_H_
#define WARPX_ACCELERATORLATTICE_LATTICEELEMENTS_SOLENOID_H_

#include "LatticeElementBase.H"
#include "HardEdged_K.H"
#include "Utils/WarpXConst.H"

#include <AMReX_REAL.H>
#include <AMReX_ParmParse.H>
#include <AMReX_GpuContainers.H>

#include <string>
#include <cmath>

// Specifies a field that models the field generated by a solenoidal field,
// an axisymmetric field expansion

struct SolenoidDevice;

struct Solenoid
    : LatticeElementBase
{

    Solenoid ();

    ~Solenoid () = default;

    /**
     * \brief Read in an element and add it to the lists
     *
     * @param[in] pp_element The ParmParse instance to read in the data
     * @param[inout] z_location The current z location in the lattice
     */
    void
    AddElement (amrex::ParmParse & pp_element, amrex::ParticleReal & z_location);

    /**
     * \brief Write the element information to the device
     */
    void
    WriteToDevice ();

    // Host variables read from input file
    std::vector<amrex::ParticleReal> h_scale;
    std::vector<amrex::ParticleReal> h_freq;
    std::vector<amrex::ParticleReal> h_theta;
    std::vector<std::vector<amrex::ParticleReal>> h_e_coef;
    std::vector<std::vector<amrex::ParticleReal>> h_b_coef;

    // Device variable read from input files
    amrex::Gpu::DeviceVector<amrex::ParticleReal> d_scale;
    amrex::Gpu::DeviceVector<amrex::ParticleReal> d_freq;
    amrex::Gpu::DeviceVector<amrex::ParticleReal> d_theta;
    amrex::Gpu::DeviceVector<std::vector<amrex::ParticleReal>> d_e_coef;
    amrex::Gpu::DeviceVector<std::vector<amrex::ParticleReal>> d_b_coef;

    /**
     * \brief Returns the device level instance with the lattice information
     */
    SolenoidDevice GetDeviceInstance () const;


};

// Instance that is trivially copyable to the device.

struct SolenoidDevice
{

    /**
     * \brief Initializes the data and pointer needed to reference the lattice element info
     *
     * @param[in] h_solenoid host level instance that this is associated with
     */
    void InitSolenoidDevice (Solenoid const& h_solenoid);

    int nelements = 0;

    const amrex::ParticleReal* AMREX_RESTRICT d_zs_arr;
    const amrex::ParticleReal* AMREX_RESTRICT d_ze_arr;
    const amrex::ParticleReal* AMREX_RESTRICT d_scale_arr;
    const amrex::ParticleReal* AMREX_RESTRICT d_freq_arr;
    const amrex::ParticleReal* AMREX_RESTRICT d_theta_arr;
    const std::vector<amrex::ParticleReal>* AMREX_RESTRICT d_e_coef_arr;
    const std::vector<amrex::ParticleReal>* AMREX_RESTRICT d_b_coef_arr;

    /**
     * \brief Fetch the field of the specified element at the given location
     *
     * @param[in] ielement the element number
     * @param[in] x, y, z the particle position in the lab frame
     * @param[in] m_time the current time in the lab frame
     * @param[out] Ex, Ey, Ez, Bx, By, Bz the fetched field in the lab frame
     */
    AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
    void get_field (const int ielement,
                    const amrex::ParticleReal x,
                    const amrex::ParticleReal y,
                    const amrex::ParticleReal z,
                    const amrex::ParticleReal m_time,
                    amrex::ParticleReal& Ex,
                    amrex::ParticleReal& Ey,
                    amrex::ParticleReal& Ez,
                    amrex::ParticleReal& Bx,
                    amrex::ParticleReal& By,
                    amrex::ParticleReal& Bz) const
    {

        const amrex::ParticleReal zs = d_zs_arr[ielement];
        const amrex::ParticleReal ze = d_ze_arr[ielement];
        const amrex::ParticleReal scale = d_scale_arr[ielement];
        const amrex::ParticleReal freq = d_freq_arr[ielement];
        const amrex::ParticleReal theta = d_theta_arr[ielement];
        const amrex::Vector<amrex::ParticleReal> e_coef = d_e_coef_arr[ielement];
        const amrex::Vector<amrex::ParticleReal> b_coef = d_b_coef_arr[ielement];

        constexpr amrex::ParticleReal pi = MathConst::pi;
        constexpr amrex::ParticleReal c = PhysConst::c;

        const int n_coef = sizeof(e_coef)/2;
        const amrex::ParticleReal zlen = ze - zs;
        const amrex::ParticleReal xl = 2*pi*freq/c;
        const amrex::ParticleReal tmpcos = cos((2*pi*freq*m_time) + theta);
        const amrex::ParticleReal tmpsin = sin((2*pi*freq*m_time) + theta);

        amrex::ParticleReal zz = z - ze + zlen/2;
        amrex::ParticleReal ez = e_coef[0]/2;
        amrex::ParticleReal ezp = 0.0;
        amrex::ParticleReal ezpp = 0.0;
        amrex::ParticleReal ezppp = 0.0;
        for (int k = 1; k < n_coef; ++k){
            ez = ez + e_coef[2*k-1]*cos(2*pi*k*zz/zlen) + e_coef[2*k]*sin(2*pi*k*zz/zlen);
            ezp = ezp - (2*pi*k*zz/zlen)*e_coef[2*k-1]*sin(2*pi*k*zz/zlen) + (2*pi*k*zz/zlen)*e_coef[2*k]*cos(2*pi*k*zz/zlen);
            ezpp = ezpp - pow(2*pi*k*zz/zlen,2)*e_coef[2*k-1]*cos(2*pi*k*zz/zlen) - pow(2*pi*k*zz/zlen,2)*e_coef[2*k]*sin(2*pi*k*zz/zlen);
            ezppp = ezppp + pow(2*pi*k*zz/zlen,3)*e_coef[2*k-1]*sin(2*pi*k*zz/zlen) - pow(2*pi*k*zz/zlen,3)*e_coef[2*k]*cos(2*pi*k*zz/zlen);
        }
        ez = ez*scale;
        ezp = ezp*scale;
        ezpp = ezpp*scale;
        ezppp = ezppp*scale;

        amrex::ParticleReal f1 = -(ezpp + ez*xl*xl)/4.0;
        amrex::ParticleReal f1p = -(ezppp + ezp*xl*xl)/4.0;
        amrex::ParticleReal r2 = x*x + y*y;

        Ex = -x*(ezp/2 + f1p*r2/4)*tmpcos;
        Ey = -y*(ezp/2 + f1p*r2/4)*tmpcos;
        Ez = (ez + f1*r2)*tmpcos;
        Bx = y*xl/c*(ez/2 + f1*r2/4)*tmpsin;
        By = -x*xl/c*(ez/2 + f1*r2/4)*tmpsin;
        Bz = 0.0;

    }

};

#endif // WARPX_ACCELERATORLATTICE_LATTICEELEMENTS_SOLENOID_H_
